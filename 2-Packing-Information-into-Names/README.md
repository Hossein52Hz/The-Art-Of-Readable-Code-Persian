
<div dir='rtl'>

# فصل دوم: قرار دادن اطلاعات در نام‌ها

</div>
<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/2-Packing-Information-into-Names/img-2-1.png" />
</p>


<div dir='rtl'>

در نام گذاری یک متغیر، یک تابع یا یک کلاس، تعداد زیادی اصول مشابه وجود دارد که باید در آن‌ها اعمال کنید. ما دوست داریم به یک نام، به عنوان یک کامنت کوچک فکر کنیم.حتی اگر فضای زیادی وجود ندارد، می‌توانید اطلاعات زیادی را با انتخاب یک نام خوب به خواننده منتقل کنید.

> **_کلید طلایی:_**  اطلاعات را در نام‌های خود قرار دهید.

بسیاری از نام‌هایی که ما در برنامه‌نویسی می‌بینیم مبهم هستند، مانند tmp. حتی کلماتی که ممکن است منطقی به نظر برسند مانند size یا get، نیز اطلاعات زیادی را در خود جای نمی‌دهند. این فصل به شما نشان می‌دهد چگونه نام‌هایی انتخاب کنید که اطلاعات زیادی را در خود دارند.

این فصل به شش موضوع خاص می‌پردازد:

* انتخاب کلمات خاص
* اجتناب از نام‌های عمومی(یا دانستن اینکه چه زمانی از آن‌ها استفاده کنید)
* استفاده از نام‌های واقعی1 بجای نام‌های انتزاعی
* افزودن اطلاعات اضافی به یک نام با استفاده از پیشوند یا پسوند
* تصمیم گیری در مورد اینکه یک نام چه مدت باید استفاده شود
* استفاده از قالب بندی نام برای افزودن اطلاعات اضافی

## انتخاب کلمات خاص

بخشی از قرار دادن اطلاعات در نام‌ها به انتخاب کلماتی بازمی‌گردد که بسیار خاص هستند. در این بین باید به اجتناب از کلمات تهی1 دقت داشته باشید.

به عنوان مثال کلمه get در مثال زیر خیلی غیرخاص است:

</div>


```
def GetPage(url):
    ...
```
<div dir='rtl'>

کلمه get چیز زیادی به ما نمی‌گوید. آیا این متد get یک صفحه را از یک cache محلی می‌گیرد یا از یک دیتابیس و یا از اینترنت؟ اگر منظور از get در اینجا این است که چیزی را از اینترنت می‌گیرد یک کلمه خاص‌تر همچون ()FetchPage یا ()DownloadPage گزینه بهتری است.

در اینجا مثالی از یک کلاس BinaryTree یا درخت جستجوی دودویی را داریم:
</div>

```
class BinaryTree {
    int Size();
    ...
};
```
<div dir='rtl'>

شما انتظار دارید که متد size() چه چیزی را به عنوان خروجی برگرداند؟ ارتفاع درخت؟ تعداد گره‌ها؟یا میزان مصرف حافظه از لحظه پیمایش درخت؟

مشکل این است که size() اطلاعات زیادی را به خواننده انتقال نمی‌دهد. می‌توان از یک نام کمی خاص‌تر همچون Height() ،NumNodes()  یا MemoryBytes() استفاده کرد.

به عنوان مثالی دیگر، فرض کنید یک کلاس مرتب سازی از Thread دارید:
</div>

```
class Thread {
    void Stop();
    ...
};
```
<div dir='rtl'>

نام Stop() مناسب است اما بستگی به این دارد که دقیقاً چه کاری انجام می‌دهد. احتمالاً نام خاص‌تر نیز وجود داشته باشد، برای نمونه اگر یک عملیات سنگین برگشت ناپذیر است احتمالاً استفاده از Kill() به جای آن بهتر خواهد بود. یا اگر راهی برای Resume() کردن آن وجود داشته باشد، بهتر است از Pause() استفاده کنید.


## پیدا کردن کلمات مشابه

<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/2-Packing-Information-into-Names/img-2-2.png" />
</p>

از اینکه از یک فرهنگ لغت استفاده کنید یا از دوست خود درخواست کنید که نام بهتری را پیشنهاد دهد، نترسید. زبان انگلیسی یک زبان غنی است و کلمات بسیار زیادی برای انتخاب شما وجود دارند.

در اینجا مثال‌های مختلفی را برای یک کلمه آورده‌ایم، نسخه‌های مشابه مختلفی که ممکن است با توجه به شرایط شما، کاربرد داشته باشند:

| معادل/مترادف‌ها   |      کلمه      |
|----------|:-------------:|
|  deliver, dispatch, announce, distribute, route | Send |
|    search, extract, locate, recover   | Find |
| launch, create, begin, open | Start |
| create, set up, build, generate, compose, add, new | Make |

با این حال افراط نکنید. در زبان PHP تابعی برای explode() یک رشته وجود دارد. این اسمی است که می‌توان معانی مختلفی از آن برداشت کرد و تصویر خوبی از شکستن چیزی به تکه‌های مختلف را نشان می‌دهد، اما تفاوت آن با split() چیست؟ (این‌ها دو تابع مختلف هستند، اما حدس زدن تفاوت آن‌ها بر اساس نام‌شان کار سختی است).

> **_کلید طلایی:_**  بهتر است نام گذاری شفاف و دقیق باشد تا اینکه باحال به نظر برسد.

## اجتناب از نام‌های عمومی مانند tmp و retval

نام‌هایی مانند tmp، retval و foo معمولا نشان دهنده بهانه هستند، به این معنی که من نمی‌توانم به یک نام خوب فکر کنم. بجای استفاده از یک نام تهی مانند این، نامی انتخاب کنید که ارزش موجودیت یا هدف شما را توصیف کند.

به عنوان مثال در تابع javascript زیر از retval استفاده شده است:
</div>

``` 
var euclidean_norm = function (v) {
    var retval = 0.0;
    for (var i = 0; i < v.length; i += 1)
        retval += v[i] * v[i];
    return Math.sqrt(retval);
};

```

<div dir='rtl'>
استفاده از retval زمانی که نمی‌توانید برای برگرداندن مقدار، به یک نام بهتر فکر کنید، وسوسه انگیز است. اما retval اطلاعات بیشتری نسبت به این جمله که « من یک مقدار برگشت داده شده هستم » ندارد.

یک نام بهتر هدف متغیر یا ارزش موجود در آن را توصیف می‌کند. در این مورد، متغیر مجموع توان دوم‌های v را حساب می‌کند. پس sum_squares‌ نام بهتری است. این نام هدف متغیر را که از کجا آمده آشکار می‌کند و ممکن است در رفع یک اشکال کمک کند.

به عنوان نمونه، تصور کنید که این متغیر داخل یک حلقه به صورت تصادفی بوده است:

</div>

```
retval += v[i];
```

<div dir='rtl'>

اگر نام متغیر sum_squares باشد خیلی واضح‌تر است:
</div>

```
sum_squares += v[i];  // Where's the "square" that we're summing? Bug!
```
<div dir='rtl'>
> **_کلید طلایی:_**  نام retval اطلاعات زیادی را داخل خود ندارد. به جای آن از یک نام که مقدار متغیر را توصیف می‌کند استفاده کنید.

با این وجود در برخی موارد، نام‌های عمومی معنی کاری که انجام می‌دهند را شامل می‌شوند. بیایید به زمانی که استفاده از آن‌ها منطقی به نظر می‌رسد نگاهی بیندازیم.

## tmp
یک مورد کلاسیک از جابجایی دو متغیر را در نظر بگیرید:
</div>


```
if (right < left) {
    tmp = right;
    right = left;
    left = tmp;
```

<div dir='rtl'>

در مواردی مشابه کد بالا، نام tmp کاملا خوب است. تنها هدف متغیر، ذخیره سازی موقت با عمری کوتاه در چند خط است. نام tmp معنی خاصی را به خواننده منتقل می‌کند به این معنی که این متغیر هیچ وظیفه دیگری ندارد. این متغیر به تابع دیگری ارسال نمی‌شود و یا ریست یا مورد استفاده مجدد قرار نمی‌گیرد.

اما در مثال بعدی، tmp بیهوده استفاده شده است(کافی بود به جای tmp موارد جدید را به همان user_info اضافه می‌کردیم و نیازی به tmp نبود):

</div>

```
String tmp = user.name();
tmp += " " + user.phone_number();
tmp += " " + user.email();
...
template.set("user_info", tmp);
```

<div dir='rtl'>
حتی اگر این متغیر دارای طول عمر کوتاهی باشد، ذخیره سازی موقت، مهم‌ترین چیز درباره این متغیر نیست. در عوض، نامی مثل user_info توصیف بیشتری را داراست.

در مثال زیر tmp باید در نام باشد، اما فقط به عنوان قسمتی از آن:
</div>

```
tmp_file = tempfile.NamedTemporaryFile()
...
SaveData(tmp_file, ...)
```

<div dir='rtl'>

توجه داشته باشید که ما نام متغیر را tmp_file نام گذاری کردیم و نه فقط tmp، چون یک شئ فایل است. تصور کنید اگر ما فقط آن را tmp صدا می‌زدیم چه اتفاقی می‌افتاد:
</div>

```
SaveData(tmp, ...)
```

<div dir='rtl'>
تنها با نگاه به همین یک خط از کد، مشخص نمی‌شود که tmp یک فایل است یا اسم یک فایل و یا حتی ممکن است داده‌ای باشد که در جایی نوشته خواهد شد.

> **_کلید طلایی:_**  نام tmp باید تنها در مواردی استفاده شود که متغیر عمر کوتاهی داشته و موقتی بودن آن، مهمترین حقیقت درباره آن باشد.

## حلقه تکرار

نام‌هایی مانند i، j، iter و it معمولا به عنوان شاخص و تعداد تکرار حلقه استفاده می‌شوند. اگرچه این اسامی عمومی هستند، اما به معنی «من یک شمارنده هستم» شناخته می‌شوند. در حقیقت، اگر یکی از این نام‌ها را برای اهداف دیگری استفاده کنید باعث سردرگمی دیگران می‌شود، پس این کار را نکنید.

اما بعضی اوقات نسبت به i و j و k نام‌های بهتری نیز وجود دارد. برای نمونه در حلقه‌های زیر به دنبال این هستیم که بفهمیم کدام کاربر متعلق به کدام club است:

</div>

```
for (int i = 0; i < clubs.size(); i++)
    for (int j = 0; j < clubs[i].members.size(); j++)
        for (int k = 0; k < users.size(); k++)
            if (clubs[i].members[k] == users[j])
                cout << "user[" << j << "] is in club[" << i << "]" << endl;

```

<div dir='rtl'>

در دستور if موارد members[] و users[] از index اشتباهی استفاده می‌کنند. اشکالاتی شبیه این به سختی کشف می‌شوند، چرا که این خط از کد در حالت جداگانه1 خوب به نظر می‌رسد.
</div>

```
if (clubs[i].members[k] == users[j])
```

<div dir='rtl'>

در این مورد استفاده از نام‌های دقیق‌تر کمک بیشتری می‌کند. به جای استفاده از شمارنده‌های حلقه (i, j, k)، انتخاب مناسب‌تر (club_i, members_i, users_i) است که به شکل خلاصه‌تر می‌توان از (ci, mi, ui) استفاده نمود:

</div>

```
if (clubs[ci].members[ui] == users[mi])  # Bug! First letters don't match up
```

<div dir='rtl'>

در صورت استفاده صحیح، حرف اول شمارنده با حرف اول آرایه مطابقت خواهد داشت:

</div>

```
if (clubs[ci].members[mi] == users[ui])  # OK. First letters match.
```

<div dir='rtl'>

## قانون در مورد نام‌های عمومی

همان گونه که متوجه شدید، در شرایطی نام‌های عمومی مفیدتر هستند.

> **_کلید طلایی:_**  اگر می‌خواهید از یک نام عمومی مانند tmp، it یا retval استفاده کنید، حتما دلیل خوبی برای انجام این کار داشته باشید.

این قابل درک است که وقتی هیچ کلمه بهتری به ذهنتان نرسید، راحت‌ترین کار به کار بردن یک نام بدون معنی مانند foo و پرداختن به ادامه کار است. اما اگر عادت کنید که زمان بیشتری برای فکر کردن در مورد نام خوب اختصاص دهید، به مرور ماهیچه نام‌گذاری را در خود به گونه‌ای خواهید ساخت که به سرعت آن را پرورش دهید.( منظور این است که تمرین در مورد نام‌گذاری همچون تمرین ورزشی که باعث ظاهر شدن عضلات و قوی‌تر شدن آن‌ها می‌شود، ذهن شما را قوی‌تر می‌کند و کافی است تمرین کنید و وقت بیشتری برای انتخاب نام بهتر قرار دهید).

## نام‌های واقعی را نسبت به نام‌های انتزاعی ترجیح دهید

<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/2-Packing-Information-into-Names/img-2-3.png" />
</p>

هنگام نام‌گذاری یک متغیر، تابع یا دیگر عناصر بجای نام‌های انتزاعی آنها را به شکل به هم پیوسته و واقعی1 توصیف کنید. به عنوان مثال در نظر بگیرید که یک متد داخلی را serverCanStart() نامیده‌اید(که تست می‌کند ایا سرور می‌تواند روی یک پورت TCP/IP گوش کند یا نه). نام ServerCanStart() تا حدودی انتزاعی است، یک نام دقیق‌تر می‌تواند CanListenOnPort() باشد. این نام مستقیما توصیف می‌کند که متد چه کاری انجام خواهد داد. در دو مثال بعدی این موضوع را به شکل دقیق‌تری بررسی خواهیم کرد.

## مثال: DISALLOW_EVIL_CONSTRUCTORS

این مثال مربوط به کدپایه در گوگل است. در C++ اگر شما یک کپی از سازنده و یا انتساب عملگر2 برای کلاس خود تعریف نکنید، یک مقدار پیش فرض اعمال می‌شود. اگر چه این کار مفید است، ولی این متدها به راحتی می‌توانند منجر به نشت حافظه3 و خرابکاری‌های دیگری شوند، چرا که در پشت صحنه، در جایی که احتمالا متوجه آن‌ها نشده‌اید، اجرا شده‌اند. 

به همین دلیل، گوگل با استفاده از یک ماکرو، قانونی برای عدم اجازه به این سازنده‌های شیطانی(evil)4 دارد:

</div>

```
class ClassName {	
    private:
      DISALLOW_EVIL_CONSTRUCTORS(ClassName);
    public:
      ...
  };
```

<div dir='rtl'>

ماکرو به صورت زیر تعریف شده است:

</div>

```
#define DISALLOW_EVIL_CONSTRUCTORS(ClassName) \
    ClassName(const ClassName&); \
    void operator=(const ClassName&);
```
<div dir='rtl'>

با قرار دادن این ماکرو در بخش private کلاس، این دو متد به صورت خصوصی شده و بنابراین حتی به صورت تصادفی نیز نمی‌توانند به صورت عمومی مورد استفاده قرار گیرند.

نام DISALLOW_EVIL_CONSTRUCTORS نام خوبی نیست. استفاده از کلمه evil موضعی بیش از حد جدی را برای یک اشکال قابل بحث به کاربر منتقل می‌کند. از همه مهم‌تر، خیلی شفاف نیست که چه ماکرویی غیر مجاز است. آیا این عبارت، متد operator=() را قبول می‌کند یا نه و اینکه حتی یک سازنده نیز نیست. این نام سال‌ها مورد استفاده قرار می‌گرفت اما در نهایت با چیزی کمتر تحریک کننده و دقیق‌تر بود جایگزین شد:

</div>

```
#define DISALLOW_COPY_AND_ASSIGN(ClassName) ...
```

<div dir='rtl'>

## مثال: --run_locally

یکی از برنامه‌های ما، یک پرچم1 خط فرمان2 اختیاری به نام –run_locally داشت. این پرچم باعث می‌شد تا برنامه ضمن چاپ اطلاعات اضافی در مورد اشکال‌زدایی3، کندتر اجرا شود. به همین دلیل معمولا زمانی استفاده می‌شد که تست روی یک دستگاه محلی مثل لپتاپ انجام می‌گرفت و نه زمانی که برنامه روی یک سرور به صورت از راه دور4 اجرا می‌شد و کارایی برای ما مهم بود.

شما می‌توانید متوجه شوید که این نام –run_locally از کجا آمده، اما چند اشکال در آن وجود دارد:

* عضو جدید تیم نمی‌داند که این پرچم چه کاری انجام می‌دهد. او هنگام اجرای برنامه به صورت لوکال، از آن استفاده می‌کند اما نمی‌داند چرا چنین چیزی نیاز است.

* گاهی اوقات نیاز داریم که اطلاعات اشکال‌زدایی را در حین اجرای برنامه به صورت ریموت چاپ کنیم. ارسال –run_locally به یک برنامه که به صورت ریموت در حال اجرا می‌باشد، خنده دار به نظر می‌رسد و فقط گیج کننده است.

* گاهی اوقات ما در حین گرفتن تست کارایی به صورت لوکال، نمی‌خواهیم که ورود به سیستم کند شود، بنابراین از –run_locally استفاده نمی‌کنیم.
    
مشکل این است که –run_locally به دلیل شرایطی که معمولا از آن استفاده می‌شود، نام گذاری شده است. در عوض، یک پرچم با نامی شبیه –extra_logging مستقیم و صریح‌تر خواهد بود.

اما اگر –run_locally به انجام کارهای بیشتری از ورود به سیستم نیاز داشته باشد چه باید کرد؟ برای نمونه، فرض کنید که به راه اندازی و استفاده از یک پایگاه داده محلی خاص نیاز داشته باشد. اکنون نام –run_locally وسوسه انگیزتر است چرا که این نام می‌تواند هر دو کار «راه اندازی» و «استفاده از یک پایگاه داده محلی خاص» را به شکل همزمان در خود داشته باشد.

اما استفاده از این نام برای این اهداف، می‌تواند مبهم و غیرمستقیم باشد. راه حل بهتر این است که پرچم دومی به نام --use_local_database نیز ایجاد کنیم. حتی اگر مجبور هستید که از دو پرچم استفاده کنید، این کار را انجام دهید، چرا که این پرچم‌ها دقیق‌تر هستند. آن‌ها سعی نمی‌کنند که دو ایده متعامد را در یک کلمه بگنجانند و این اختبار را به شما می‌دهند که در مواقع لزوم تنها از یکی از آن‌ها استفاده کنید.

## ضمیمه کردن اطلاعات اضافه به یک نام

<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/2-Packing-Information-into-Names/img-2-4.png" />
</p>

همان‌گونه که قبلا اشاره کردیم، نام یک متغیر شبیه یک کامنت کوچک است. حتی اگر فضای زیادی وجود نداشته باشد، هر اطلاعات اضافی که در یک نام می‌گنجانید، هر بار که یک متغیر دیده می‌شود، این اطلاعات نیز دیده خواهد شد.

بنابراین اگر چیزهایی درباره یک متغیر خیلی مهم بوده و خواننده باید آن‌ها را بداند، ارزش دارد که کلمات بیشتری به نام متغیر اضافه کنید. برای مثال فرض کنید متغیری دارید که شامل یک رشته hexadecimal‌ به صورت زیر است:

</div>

```
string id;  // Example: "af84ef845cd8"
```

<div dir='rtl'>

اگر این مهم است که خواننده فرمت ID را به یاد داشته باشد، پس بهتر است از نام hex_id استفاده کنید.

## مقدارها و واحدها

اگر متغیرهای شما برای اندازه‌گیری هستند(مانند یک لحظه از زمان یا یک تعداد از بایت‌ها)، اینکه واحد آن متغیر را نیز در نام متغیر بگنجانید کمک کننده است.

برای مثال در اینجا یک کد javascript داریم که میزان زمان load یک صفحه وب را اندازه گیری می‌کند:

</div>

```
var start = (new Date()).getTime();  // top of the page
...
var elapsed = (new Date()).getTime() - start;  // bottom of the page
document.writeln("Load time was: " + elapsed + " seconds");
```

<div dir='rtl'>

هیچ خطای واضحی در این کد وجود ندارد، اما این کد درست کار نمی‌کند. زیرا getTime() زمان را بر اساس واحد میلی ثانیه1 بر می‌گرداند و نه ثانیه2.

با افزودن _ms به نام متغیرها می‌توانیم همه چیز را دقیق‌تر بیان کنیم:

</div>

```
var start_ms = (new Date()).getTime();  // top of the page
...
var elapsed_ms = (new Date()).getTime() - start_ms;  // bottom of the page
document.writeln("Load time was: " + elapsed_ms / 1000 + " seconds");
```

<div dir='rtl'>

علاوه بر واحد زمان، چندین واحد دیگر نیز وجود دارند که در برنامه‌نویسی کاربرد زیادی دارند. در ادامه جدولی از واحدهای استفاده شده در پارامترهای تابع و نسخه‌های بهتری از آن‌ها را می‌توانید ببینید:


| پارامترهای تابع   |      تغییر نام پارامتر به واحد کد شده[1]      |
|----------|:-------------:|
|  Start(int **delay** )  | delay → **delay_secs**  |
|  CreateCache(int **size** )  | size → **size_mb**  |
|  ThrottleDownload(float **limit**)  | limit → **max_kbps**  |
|  Rotate(float **angle**)  | angle → **degrees_cw**  |


## کد کردن سایر خصوصیات1 مهم

تکنیک ضمیمه کردن اطلاعات بیشتر به یک نام، فقط به مقادیر واحدها محدود نمی‌شود. شما باید هر زمان که مورد چالش‌برانگیز یا تعجب برانگیزی در مورد متغیر دیدید، از این تکنیک استفاده کنید.

به عنوان مثال، خیلی از سوء استفاده‌های امنیتی ناشی از عدم درک برخی از داده‌هایی است که برنامه شما دریافت کرده و هنوز در وضعیت امن قرار ندارند. برای این کار ممکن است بخواهید از نام متغیرهایی شبیه untrustedUrl یا unsafeMessageBody استفاده کنید. بعد از فراخوانی توابعی که ورودی ناامن را حذف می‌کنند، نام متغیر برای نتیجه کار ممکن است trustedUrl یا safeMessageBody باشد.

جدول زیر مثال‌های بیشتری در مورد زمان‌هایی که باید اطلاعات بیشتری در نام گنجانده شود را نشان می‌دهد:

|  موقعیت| نام متغیر | نام مناسب‌تر  |
|--|--|--|
| یک پسورد به صورت متنی است و باید قبل از پردازش بعدی رمزنگاری شود. | Plaintext_password | Password |
| یک کاربر کامنتی گذاشته است که باید قبل از نمایش escape شود. | Comment | Unscaped_comment |
| کدهای html که به UTF-8 تبدیل شده اند. | Html | Html_utf-8 |
| داده‌های ورودی در url رمز شده هستند. | Data | Data_urlenc |


شما نباید از خصوصیاتی مانند _unescaped یا _utf-8 برای هر متغیری در برنامه خود استفاده کنید. آن‌ها در مکان های پر اهمیت قرار دارند که در صورت اشتباه بودن متغیر، یک باگ می‌تواند به آسانی در آن مخفی شده باشد، به خصوص اگر آن باگ امنیتی باشد که پیامدهای آن وخیم است. اساسا اگر یک مورد بحرانی وجود دارد که خواننده باید از آن اطلاع پیدا کند، آن را در نام متغیر لحاظ کنید.

## آیا این نماد مجارستانی(Hungarian Notation1) است؟

در واقع Hungarian Notation یک سیستم نام گذاری است که به شکل گسترده در شرکت مایکروسافت استفاده شده است. در این سیستم نوع هر متغیر به صورت پیشوند در نام آن اضافه می‌شود. در جدول زیر می‌توانید چند مثال از آن را مشاهده کنید:

| نام | معنی |
|--|--|
| pLast | اشاره‌گر (p) که به آخرین المان یک ساختارداده اشاره می‌‌کند |
| pszBuffer | اشاره‌گر (p) برای اشاره به یک zero-terminated (z) string (s) در بافر | 
| Cch | یک شمارنده(count (c)) تعداد کاراکترها(characters (ch)) |
| mpcopx | یک map (m) از یک اشاره‌گر به یک color (pco) که به یک length (px) با طول متغیر x اشاره می‌کند. |

در واقع این استاندارد که نمونه‌ای از ضمیمه کردن خصوصیات به نام‌ها است، سیستمی رسمی و سخت گیرانه است که روی نام گذاری مجموعه، با توجه به خصوصیات خاص آن متمرکز شده است. اما آنچه در این بخش مد نظر ما می‌باشد سیستمی گسترده‌تر و غیر رسمی است: یعنی مشخصه‌های مهم یک متغیر را شناسایی کرده و در صورت لزوم آن‌ها را به طور خوانا نام‌گذاری کنید. مثلا به عنوان یک پیشنهاد می‌توانید آن‌ها را یادداشت‌های انگلیسی1 بنامید.

<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/2-Packing-Information-into-Names/img-2-5.png" />
</p>

## طول یک نام چقدر باید باشد؟

هنگام انتخاب یک نام خوب، این محدودیت ضمنی وجود دارد که نباید آن نام خیلی طولانی باشد. هیچ کسی دوست ندارد با شناسه هایی مانند این کار کند:

</div>

```
newNavigationControllerWrappingViewControllerForDataSourceOfClass
```

<div dir='rtl'>
هرچه یک نام طولانی‌تر باشد، به خاطر سپردن آن، سخت‌تر شده و به فضای بیشتری روی صفحه نمایش نیاز خواهد داشت، و گاهی باعث می‌شود که یک خط به چندین خط اضافی شکسته1 شود.
 
از طرف دیگر برنامه‌نویس‌ها می‌توانند با انتخاب نام‌های تک کلمه‌ای، این توصیه را در نظر نگیرند. بنابراین چگونه باید این trade-off را مدیریت کنید؟ چگونه بین نام گذاری یک متغیر به d، days و یا days_since_last_update تصمیم گیری می‌کنید؟
بهترین پاسخ دقیقا به نحوه استفاده از این متغیر بستگی دارد. به همین دلیل و برای کمک به شما چند راهنمایی جهت این تصمیم گیری ارائه شده است.
 
##نام‌های کوتاه برای قلمرو‌های2 کوتاه مناسب هستند

وقتی به یک تعطیلات کوتاه می‌روید معمولا چمدان‌های کمتری نسبت به تعطیلات طولانی آماده می‌کنید. به همین ترتیب شناسه‌هایی که قلمرو کوچکی دارند نیازی به حمل اطلاعات زیاد در نام خود ندارند. یعنی شما می‌توانید از نام‌های کوتاه‌تر برای آن‌ها استفاده کنید زیرا همه اطلاعات(همچون نوع متغیر، مقداردهی اولیه آن و چگونگی انقضاء آن) به راحتی دیده می‌شود:

</div>

```
if (debug) {
    map<string,int> m;
    LookUpNamesNumbers(&m);
    Print(m);
}
```
<div dir='rtl'>
حتی اگر m هیچ اطلاعاتی را در خود جای نداده باشد، مشکلی ایجاد نمی‌شود، چرا که خواننده در این حال تمام اطلاعات مورد نیاز برای درک این کد را در اختیار دارد.

حال فرض کنید m یک عضو کلاس یا یک متغیر سراسری1 بود و شما این قطعه کد را مشاهده می‌کردید:
</div>

```
LookUpNamesNumbers(&m);
Print(m);
```

<div dir='rtl'>
بی‌شک این کد خوانایی کمتری دارد، زیرا مشخص نیست که نوع یا هدف m چیست. بنابراین اگر یک شناسه قلمرو بزرگی داشته باشد، نام آن باید اطلاعات کافی را برای شفاف شدن آن ارائه دهد.

## نوشتن نام‌های طولانی-به هرحال مشکلی ندارد

دلایل خوب زیادی برای اجتناب از نام‌های طولانی وجود دارد اما این سخن که «تایپ کردن آن‌ها سخت است» جزو دلایل منطقی محسوب نمی‌شود. هر ویرایشگر متن برنامه‌نویسی قابلیت تکمیل کننده کلمه1 را دارد. در کمال تعجب، بعضی از برنامه‌نویسان از این ویژگی اطلاعی ندارند. اگر شما تا کنون این ویژگی را امتحان نکرده اید، لطفا خواندن کتاب را کنار گذاشته و آن را در ویرایشگر کدنویسی خود امتحان کنید:

1. چند حرف اول نام مد نظر خود را تایپ کنید.
2. دستور تکمیل کننده کلمه را اجرا کنید.
3. اگر نام کامل شده صحیح نیست، دستور را تکرار کنید تا نام صحیح نمایش داده شود.

بسیار جالب است که این قابلیت روی هر نوع فایل، در هر زبانی برای هر علامتی2 کار می‌کند، حتی اگر در حال نوشتن کامنت باشید.
</div>

```
| ویرایشگر | دستور |
|--|--|
| Vi | Ctrl-p |
| Emacs | Meta-/ (hit ESC, then /) |
| Eclipse | Alt-/ |
| IntelliJ IDEA | Alt-/ |
| ExtMate | ESC |

```

<div dir='rtl'>

## مخفف‌ها1 و اختصارها2

گاه برای کوچک نگه داشتن نام‌ها برنامه‌نویسان به مخفف نویسی و مختصر نویسی متوسل می‌شوند، همچون نام‌گذاری یک کلاس با نام BEManager به جای BackEndManager. ولی سوال این جاست که آیا این کوچک شدن‌ها ارزش ایجاد سردرگمی را دارد؟

تجربه به ما ثابت کرده است که معمولا، اختصار نویسی پروژه‌های خاص، ایده بدی است. این اختصار نویسی‌ها در مواقع زیادی برای افراد جدیدی که به پروژه اضافه می‌شوند رمزآلود و ترسناک بوده و حتی با گذشت زمان برای خود نویسندگان نیز رمزآلود و ترسناک به نظر خواهند رسید.

بنابراین قانون اصلی ما این است: **آیا یک هم تیمی جدید درک می‌کند که معنای این اسم، چیست؟** اگر پاسخ مثبت است، پس احتمالا نام مناسبی انتخاب شده است.
 
برای مثال، برای برنامه‌نویسان عادی است که از eval به جای evaluation، doc به جای document، یا str به جای string استفاده کنند. بنابراین یک هم تیمی جدید وقتی FormatStr()‌ را می‌بیند به احتمال زیاد متوجه معنی آن می‌شود. با این حال او احتمالا نمی‌فهمد که معنی BEManager چیست.

## دور انداختن کلمات زائد3

گاه کلمات داخل یک نام را می‌توان بدون از دست دادن هیچ اطلاعاتی از آن، حذف کرد. برای نمونه به جای ConvertToString() می‌توان از ToString() استفاده کرد، که در عین کوتاه‌تر بودن هیچ اطلاعاتی را نسبت به کلمه اول از دست نمی‌دهد. به همین ترتیب، استفاده از ServeLoop() به جای DoServeLoop() به همان اندازه شفاف است.

## از قالب بندی نام برای انتقال معنی آن استفاده کنید

استفاده از underscore، dash و capitalization که به ترتیب خط زیر، خط فاصله و بزرگ نویسی حرف اول کلمه هستند، می‌تواند اطلاعات زیادی را در یک نام قرار دهید. برای مثال در اینجا یک کد C++ را مشاهده می‌کنید که در آن از قراردادهای قالب بندیِ استفاده شده در پروژه‌های متن باز گوگل استفاده کرده است:

</div>

```
static const int kMaxOpenFiles = 100;
class LogReader {
  public:
    void OpenFile(string local_file);
  private:
    int offset_;
    DISALLOW_COPY_AND_ASSIGN(LogReader);
};
```
<div dir='rtl'>

داشتن قالب‌های مختلف برای موجودیت‌های مختلف، مانند نوعی از برجسته کردن سینتکس1 است که به شما در خواندن راحت‌تر کد کمک می‌کند.

اکثر قالب بندی‌های این مثال بسیار متداول هستند. از قالب بندی CamelCase (بزرگ بودن حروف اول کلمات)برای نام کلاس‌ها و از lower_separated برای نام متغیرها استفاده می‌شود.

اما برخی از قراردادها ممکن است شما را متعجب کند، به عنوان نمونه، مقدارهای ثابت2 به جای CONSTANT_NAME دارای شکل kConstantName هستند. این استایل از این مزیت برخوردار است که به راحتی از ماکروهای #define، که طبق قرارداد به صورت MACRO_NAME هستند، متمایز می‌شود. متغیرهای عضو کلاس شبیه متغیرهای عادی‌اند با این تفاوت که باید در انتهای آن‌ها یک underscore قرار گیرد، مانند offset_. در ابتدا ممکن است این قرارداد عجیب به نظر برسد اما توانایی تشخیص فوری اعضا از سایر متغیرها را بسیار زیاد می‌کند. به عنوان مثال اگر در حال مشاهده کد یک متد طولانی به صورت گذرا هستید و این خط را ببینید:
</div>

```
stats.clear();
```

<div dir='rtl'>

ممکن است متعجب شوید که آیا این stats متعلق به این کلاس است؟ آیا این کد، stats داخلی کلاس را تغییر می‌دهد؟ اگر از قرارداد member_ استفاده شده بود، شما می‌توانستید سریعا نتیجه بگیرید که stats یک متغیر محلی است. در غیر این صورت باید به صورت stats_ نام‌گذاری می‌شد.
 
## دیگر قراردادهای قالب بندی1

بسته به موضوع پروژه یا زبان برنامه‌نویسی، ممکن است قراردادهای دیگری برای قالب بندی وجود داشته باشد که می‌توانید از آن‌ها برای ایجاد نام‌هایی با اطلاعات بیشتر، استفاده کنید. برای نمونه در JavaScript:

کتاب The Good Parts1 (Douglas Crockford, O’Reilly, 2008) نویسنده پیشنهاد می‌کند که سازنده‌ها2(توابعی که از قبل تعریف شده و هنگام new یا همان ایجاد یک شئ فراخوانی می‌شوند) باید با حروف بزرگ(اول کلمات) باشند و توابع معمولی باید با یک حرف کوچک شروع شوند:

</div>

```
var x = new DatePicker();  // DatePicker() is a "constructor" function
var y = pageHeight();      // pageHeight() is an ordinary function
```

<div dir='rtl'>
در اینجا **DatePicker** یک سازنده و **pageHeight** یک تابع عادی است.

اجازه دهید مثال دیگری از JavaScript را با هم ببینیم: زمانی که تابع کتابخانه JQuery را صدا می‌زنید( که نام آن کاراکتر تکی $ است) یک قرارداد مفید این است که نتایج JQuery را نیز با یک علامت $ به صورت پیشوند بکار ببریم:

</div>

```
var $all_images = $("img");  // $all_images is a jQuery object
var height = 250;            // height is not
```

<div dir='rtl'>
در این کد واضح است که $all_images یک شئ از نتایج JQuery می‌باشد. به عنوان آخرین مثال کد HTML/CSS زیر را در نظر بگیرید. وقتی به یک تگ HTML یک id یا class اختصاص می‌دهید، هر دو underscore و dash برای مقدار آن‌ها معتبر هستند. یک قرارداد احتمالی این است که از underscore برای جداسازی کلمات در id‌ها و از dash برای جداسازی کلمات در class‌ها استفاده شود:
</div>

```
<div id="middle_column" class="main-content"> ...
```

<div dir='rtl'>
تصمیم به استفاده از چنین قراردادهایی در پروژه‌های خود یا تیم خود به شما بستگی دارد. اما از هر قرارداد دیگری که استفاده می‌کنید، در طول کل پروژه خود به آن پایبند باشید.
 
## خلاصه

موضوع این فصل به صورت خلاصه، **قرار دادن اطلاعات در نام‌های شما** بود. هدف از انجام این کار این است که خواننده بتواند اطلاعات زیادی را فقط با خواندن یک نام به دست آورد. نکات خاص پوشش داده شده در این فصل عباتند از:

* **از نام‌های خاص استفاده کنید.** برای مثال بسته به شرایطی که دارید ممکن است استفاده از کلماتی شبیه Fetch یا Download به جای Get گزینه‌های بهتری باشند.

* **از نام‌های عمومی اجتناب کنید**(مانند tmp و retval)، مگر اینکه دلیل خاصی برای استفاده از آنها وجود داشته باشد.

* از نام‌های پیوسته واقعی که چیزی را با جزئیات بیشتری شرح می‌دهند استفاده کنید. نام CanListenOnPort() نسبت به ServerCanStart() واضح‌تر است.

* **جزئیات مهم را به نام متغیرها ضمیمه کنید.** برای مثال، _ms را به آخر نام متغیری که مقدار آن میلی ثانیه است اضافه کرده و یا عبارت raw_‌ را به ابتدای متغیر پردازش نشده که نیاز به عملیات escape دارد، اضافه کنید.

* **از نام‌های طولانی برای قلمروهای بزرگتر استفاده کنید.** از نام‌های مرموز یک یا دو حرفی برای متغیرهایی که در چندین صفحه از کدها به کار می‌رود، استفاده نکنید. نام‌های کوتاه در مواقعی که متغیرها فقط در چند خط از کد (به صورت کوتاه) استفاده می‌شوند، بهتر است.
    
* **از قوانین capitalization، underscore و مواردی از این دست استفاده کنید.** برای مثال می‌توانید علامت _ را به اعضای کلاس اضافه کنید تا آن‌ها را از متغیرهای محلی تمایز دهید.
</div>

