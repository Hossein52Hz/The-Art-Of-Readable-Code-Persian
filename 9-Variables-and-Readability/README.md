<div dir="rtl">

# فصل نهم

# متغیرها و خوانایی

<p align="center">
‍   <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/9-Variables-and-Readability/img-9-1.png"/>
</p>

در این فصل خواهید دید که چگونه استفاده شلخته[1]
از متغیرها سبب سخت‌تر شدن درک برنامه می‌شود. در اینجا به طور
خاص با سه مشکل اساسی روبرو هستیم:

۱. هر چه متغیرهای بیشتری وجود داشته باشد، دنبال کردن همه آن‌ها سخت‌تر می‌شود.

۲.  هرچه محدوده یک متغیر بزرگتر باشد، شما باید پیگیری طولانی‌تری را در مورد آن انجام دهید.

۳. هرچه یک متغیر بیشتر تغییر کند، پیگیری مقدار فعلی آن  سخت‌تر می‌شود.

در ادامه و طی سه بخش نحوه مقابله با این مسائل سه گانه بررسی خواهد شد.

## از بین بردن[2] متغیرها

همان گونه که به یاد دارید در فصل هشتم نشان دادیم که
معرفی متغیر توضیح‌دهنده[3] یا خلاصه[4]
می‌تواند سبب خوانایی بیشتر کد شود. این متغیرها مفید
بودند، زیرا عبارت‌های غول پیکر را تجزیه نموده و به عنوان شکلی از مستندات
عمل می‌کردند.

اما در این بخش می‌خواهیم متغیرهایی که باعث بهبود خوانایی
کد نمی‌شوند را از بین ببریم. با حذف متغیر غیرضروری، کد جدید مختصرتر شده
و به آسانی قابل درک خواهد شد.

## متغیرهای موقتی[5] بی فایده

در کد پایتون زیر متغیر `now` را در نظر بگیرید:

</div>

```
now = datetime.datetime.now()
root_message.last_view_time = now
```

<div dir="rtl">

به نظر می‌رسد به سه دلیل، نگه داشتن متغیر `now` ارزش نداشته باشد:

* این متغیر عبارت پیچیده‌ای را تجزیه نمی‌کند.

* شفافیت خاصی را اضافه نمی‌کند، چرا که عبارت
    `datetime.datetime.now()` به اندازه کافی واضح
    است.

* از آنجا که این متغیر فقط یکبار استفاده شده است،
    بنابراین هیچ کد افزونگی را فشرده نمی‌کند.

بدون متغیر now کد به راحتی قابل
درک است:

</div>

```
root_message.last_view_time = datetime.datetime.now()
```

<div dir="rtl">

متغیرهایی مانند `now` معمولا «مانا[6]» هستند که بعد از ویرایش کد همچنان باقی
می‌مانند. این متغیر ممکن است در ابتدا در چندین مکان استفاده شده باشد و
یا حتی ممکن است کدنویس پیش بینی می‌کرده که از now 
چندین بار استفاده خواهد کرد، اما در ادامه هرگز به آن نیازی
پیدا نکرده است.

## از بین بردن نتایج واسط[7]

<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/9-Variables-and-Readability/img-9-1.png"/>
</p>

در اینجا مثالی از کد یک تابع JavaScript داریم که مقداری را از یک آرایه حذف می‌کند:

</div>

```
var remove_one = function (array, value_to_remove) {

    var index_to_remove = null;

    for (var i = 0; i \< array.length; i += 1) {

        if (array\[i\] === value_to_remove) {

            index_to_remove = i;

            break;

        }

    }

    if (index_to_remove !== null) {

        array.splice(index_to_remove, 1);

    }

};
```

<div dir="rtl">

متغیر `index_to_remove` تنها برای نگه‌داشتن نتیجه واسط(میانی) استفاده شده است. گاهی چنین متغیرهایی می‌توانند به محض دریافت نتیجه، حذف شوند:

</div>

```
var remove_one = function (array, value_to_remove) {

    for (var i = 0; i \< array.length; i += 1) {

        if (array\[i\] === value_to_remove) {

            array.splice(i, 1);

            return;

        }

    }

};
```

<div dir="rtl">

با اجازه به کد برای برگرداندن سریع، می‌توانیم از دست index_to_remove خلاص شده و کد را کمی ساده کنیم. به طور کلی این موضوع استراتژیِ خوبی است که « **یک کار را در اولین فرصت به اتمام برسانید»**.

## از بین بردن متغیرهای کنترل جریان

گاهی اوقات، الگوی زیر را در حلقه‌های کد خود
می‌بینید:

</div>

```
boolean done = false;

while (*/\* condition \*/* && !done) {

    ...

    if (...) {

        done = true;

        continue;

    }

}

```

<div dir="rtl">

متغیر `done` ممکن است از طریق حلقه در چندین مکان، برابر `true` مقداردهی شود. در اکثر اوقات کدی مانند این برای برآورده کردن برخی قوانین نانوشته است که «نباید در وسط یک حلقه، از برنامه جدا شد». و این در حالی است که اصولا چنین قانونی وجود ندارد!

متغیرهایی شبیه `done` همان چیزی است که ما آن را متغیر‌های کنترل جریان می‌نامیم. تنها هدف آن‌ها هدایت اجرای برنامه است و شامل هیچ‌گونه داده واقعی از برنامه نمی‌باشند. تجربه به ما ثابت کرده که متغیرهای کنترل جریان اغلب می‌توانند با استفاده بهتر از برنامه‌نویسی ساخت‌یافته[8] حذف شوند:

</div>

```
while (*/\* condition \*/*) {

    ...

    if (...) {

        break;

    }

}
```

<div dir="rtl">

در این مثال حذف این مشکل بسیار آسان است، اما اگر یک تجزیه ساده برای چندین حلقه تودرتو کافی نباشد باید چه کرد؟ در اینگونه موارد راه حل جابجایی کد به یک تابع جدید است(جابجایی کد داخل حلقه یا کل حلقه).

آیا می‌خواهید همکاران‌تان احساس کنند که همیشه در وضعیت «زمان مصاحبه» قرار دارند؟

`Eric Brechner` در شرکت مایکروسافت درباره این مورد که چگونه یک سوال عالی در زمان مصاحبه باید شامل حداقل سه متغیر باشد[9] صحبت کرده است. احتمالا به این دلیل که برخورد با سه متغیر به صورت هم زمان مصاحبه شونده را وادار می‌کند که سخت فکر کند! این برای مصاحبه منطقی است، جایی که شما تلاش می‌کنید یک گزینه را محدود کنید. اما آیا می‌خواهید همکاران‌تان هنگام خواندن کد شما احساس کنند که در جلسه مصاحبه حضور دارند؟

## دامنه[10] متغیرهای خود را کوچک[11] کنید

همه ما این توصیه را شنیده‌ایم که: «از متغیرهای
سراسری[12] اجتناب کنید». این توصیه خوبی است، زیرا ردیابی اینکه همه متغیرهای سراسری در کجا و چگونه استفاده شده‌اند، سخت
است. در این مورد با «آلوده کردن فضای نام[13]»
یعنی قرار دادن یک دسته از نام‌ها در آن مکان، مشکل را حل نمود چرا که ممکن
است با متغیرهای محلی شما تداخل پیدا کند و ممکن است کد هنگامی که قصد
استفاده از یک متغیر محلی را دارد به صورت تصادفی یک متغیر سراسری را تغییر
دهد(و یا برعکس).

در حقیقت این ایده خوبی است که محدوده همه متغیرها(و نه
فقط آن‌ها که سراسری هستند) را کوچک کنید.

> **_کلید طلایی:_** متغیر خود را تا حد امکان با چند خط کد، قابل مشاهده کنید

بسیاری از زبان‌های برنامه‌نویسی چندین سطح دامنه/دسترسی،
افزودن ماژول، کلاس، تابع و محدوده بلوک را ارائه می‌دهند. به صورت یک
قانون کلی، استفاده از دسترسی محدودتر بهتر است، زیرا بدان معنی است که
متغیر را می‌توان با تعداد کمتری از خطوط کد مشاهده کرد.

دلیل انجام این کار این است که به شکل موثری، تعداد متغیرهایی را که خواننده باید در یک زمان واحد به آن‌ها فکر کند، کاهش می‌دهد. اگر محدوده همه متغیرها را نصف کنید، میانگین تعداد متغیرها در محدوده در هر زمان نیز نصف خواهد شد.

به عنوان مثال فرض کنید یک کلاس خیلی بزرگ، با یک متغیر عضو دارید که فقط توسط دو متد به صورت زیر مورد استفاده قرار می‌گیرد:

</div>

```
class LargeClass {

    string str\_;

    void Method1() {

        str\_ = ...;

        Method2();

    }

    void Method2() {

        *// Uses str\_*

    }

    *// Lots of other methods that don't use str\_ ...*

};
```

<div dir="rtl">

به عبارت دیگر متغیر عضو کلاس مانند یک متغیر سراسریِ کوچک[14] در داخل قلمرو[15]  کلاس است. در کلاس‌های بزرگ، پیگیری همه متغیرهای عضو و اینکه چه متدی، کدام یک از آن‌ها را تغییر می‌دهد سخت است. هرچه تعداد این متغیرهای سراسری کوچک کمتر باشد، بهتر است. در این مثال منطقی است که متغیر str_ را به یک متغیر محلی تنزل دهیم:

</div>

```
class LargeClass {

    void Method1() {

        string str = ...;

        Method2(str);

    }

    void Method2(string str) {

        *// Uses str*

    }

    *// Now other methods can't see str.*

};
```

<div dir="rtl">

روش دیگر برای محدود کردن دسترسی اعضای کلاس این است که **تا جای ممکن متدهای استاتیک**[16] **ایجاد کنیم**. متدهای استاتیک روشی عالی برای اطلاع به خواننده است که «این خطوط کد، از دیگر متغیرها جداسازی[17] شده‌اند».

همچنین رویکرد دیگر این است که **کلاس بزرگ را به چندین کلاس کوچک‌تر تجزیه کنیم**. البته این روش در صورتی مفید است که کلاس‌های کوچک‌تر را از یکدیگر جداسازی کنیم. اگر قرار بر ساخت دو کلاس باشد که به اعضای یکدیگر دسترسی داشته باشند، در واقع هیچ کاری انجام نداده‌اید.

این قانون در مورد تجزیه فایل‌های بزرگ به فایل‌های کوچکتر یا توابع بزرگ به توابع کوچک‌تر نیز حاکم بوده و انگیزه مهمی برای انجام این کار جداسازی داده‌ها[18] از جمله متغیرها است.

البته توجه داشته باشید که زبان‌های مختلف قوانین متفاوتی در مورد یک محدوده دقیقا تا چه محدوده‌ای است دارند. در اینجا فقط به برخی از قوانین جالب توجه درباره محدوده متغیرها اشاره می‌کنیم.

## محدوده دستور IF در زبان c++

فرض کنید شما کد c++ زیر را دارید:

‍‍‍</div>

```
PaymentInfo\* info = database.ReadPaymentInfo();

if (info) {

    cout \<\< "User paid: " \<\< info->amount() \<\< endl;

}

*// Many more lines of code below ...*
```

<div dir="rtl">

متغیر `info` برای ادامه تابع در محدوده باقی خواهد ماند، بنابراین خواننده این کد ممکن است `info` را در ذهن خود نگه داشته و همواره نگران چگونگی استفاده مجدد این متغیر در ادامه باشد.

اما در C++ می‌توانیم `info` را در داخل عبارت شرطی نیز تعریف کنیم، مانند کد زیر که `info` فقط داخل دستور if استفاده شده است.:

</div>

```
if (PaymentInfo\* info = database.ReadPaymentInfo()) {

    cout \<\< "User paid: " \<\< info->amount() \<\< endl;

}
```

<div dir="rtl">

به همین دلیل خواننده به راحتی می‌تواند `info` را خارج از محدوده آن فراموش کند.

## ایجاد متغیرهای Private در JavaScript

متغیر سراسری که فقط در یک تابع استفاده شده است را در نظر بگیرید:

</div>

```
submitted = false;  *// Note: global variable*

var submit_form = function (form_name) {

    if (submitted) {

        return;  *// don't double-submit the form*

    }

    ...

    submitted = true;

};
```

<div dir="rtl">
یک متغیر سراسری مانند `submitted` می‌تواند سبب احساس وحشت در شخصی که کد را می‌خواند بشود. هرچند ظاهرا به نظر می‌رسد `submit_form()` تنها تابعی است که از `submitted` استفاده می‌کند اما شما نمی‌توانید با اطمینان این را بگویید. در حقیقت، یک فایل JavaScript  دیگر ممکن است از متغیر سراسری که `submitted`

نامیده شده است، برای هدفی دیگر استفاده کند! شما می‌توانید با قرار دادن `submitted` در داخل `closure`

(بستار) از این مشکل جلوگیری کنید:
</div>

```
var submit_form = (function () {

    var submitted = false;  *// Note: can only be accessed by the function below*

    return function (form_name) {

        if (submitted) {

            return;  *// don't double-submit the form*

        }

        ...

        submitted = true;

    };

}());
```

<div dir="rtl">
به پرانتزهای خط آخر توجه داشته باشید، تابع `anonymous` بلافاصله اجرا شده و تابع داخلی را بر می‌گرداند.

اگر تا کنون این روش را ندیده‌اید، ممکن است ابتدا عجیب به نظر برسد. این کار سبب می‌شود تا یک محدوده private که تنها تابع داخلی به آن دسترسی دارد، ایجاد شود. حال خواننده درباره موارد دیگر استفاده از submitted نگرانی ندارد. همچنین بابت ایجاد تداخل با دیگر متغیرهای سراسری با همین نام نیز نگران نخواهد بود.(برای مطالعه بیشتر درباره این روش می‌توانید به کتاب JavaScript: The Good Parts by Douglas Crockford \[O’Reilly, 2008\] مراجعه نمایید).

## دامنه سراسری JavaScript

در JavaScript اگر کلمه کلیدی var را در تعریف یک متغیر ننویسید(مثلا به جای `var x=1` بنویسید `x=1` )،متغیر در دامنه سراسری تعریف می‌شود، جایی که هر فایل JavaScript و بلوک `<script>` می‌تواند به آن دسترسی داشته باشد. به عنوان مثال:

</div>

```
<script>

    var f = function () {

        *// DANGER: 'i' is not declared with 'var'!*

        for (i = 0;  i \< 10;  i += 1) ...

    }; 

    f(); 

</script>
```

<div dir="rtl">
این کد اشتباها i را در محدوده جهانی قرار می‌دهد، بنابراین خارج از بلوک نیز امکان مشاهده آن وجود دارد:
</div>

```
<script>

    alert(i);   // Alerts '10'.  'i' is a global variable!

</script>
```

<div dir="rtl">
بسیاری از برنامه‌نویسان از این قانون محدوده اطلاع نداشته و این می‌تواند باعث باگ‌های عجیبی شود. از جمله مواقع آشکار شدن چنین باگی، هنگامی است که دو تابع، یک متغیر محلی را با نام مشابه ایجاد کرده ولی استفاده از var را فراموش می‌کنند. این تابع‌ها ندانسته دچار تداخل `(cross-talk)` می‌شوند و برنامه‌نویس بیچاره احتمالا نتیجه می‌گیرد که کامپیوترش دچار اشکال شده یا RAM او خراب شده است!

بهترین تجربه[19] برای JavaScript این است که **همیشه متغیرها را با استفاده ازکلمه کلیدی var تعریف کنید**
(مثلا var x = 1). این کار دامنه متغیر
را به تابعی که در آن تعریف شده است (یعنی داخلی‌ترین تابع) محدود
می‌کند.

## نبود محدوده‌ها در زبان Python وJavaScript

زبان‌ها‌یی مانند C++ و
Java دارای محدوده بلوک[20] هستند،
یعنی جایی که متغیرها داخل یک if، for، try یا
ساختارهایی مشابه (که دامنه تودرتوی یک بلوک محدود شده است)، تعریف
می‌شوند:

</div>

```
if (...) {

    int x = 1; 

}

x++;   *// Compile-error! 'x' is undefined.*
```

<div dir="rtl">
از سوی دیگر در زبان Python یا JavaScript متغیرهای تعریف شده در یک بلوک، در کل تابع قابل دسترس هستند. به عنوان مثال به استفاده از `example_value` در این کد پایتون که به شکل صحیح کار می‌کند توجه کنید:
</div>

```
# No use of example_value up to this point.

if request:

    for value in request.values:

        if value > 0:

            example_value = value

            break

for logger in debug.loggers:

    logger.log("Example:",  example_value)
```

<div dir="rtl">
این قانون محدوده، بسیاری از برنامه‌نویسان را متعجب کرده و فهمیدن کدی شبیه این را سخت می‌کند. در زبان‌های دیگر پیدا کردن جایی که برای اولین بار `example_value` تعریف شده است، ساده‌تر است. چرا که شما در گوشه سمت چپ، داخل تابع خود به دنبال تعریف آن می‌گردید.

این مثال اشکال دیگری نیز دارد چرا که اگر `example_value` در بخش اول کد تنظیم نشده باشد، بخش دوم پیغام خطایی[21] را به صورت `NameError` :
`‘example_value’ is not defined` ایجاد خواهد کرد. ما می‌توانیم این مشکل را برطرف کنیم و با تعریف `example_value` قبل از نقطه اشتراک آن‌ها(یعنی در عبارت‌های تودرتو)، کد را خواناتر کنیم:
</div>

```
example_value = None

if request:
    for value in request.values:
        if value > 0:
            example_value = value
            break

if example_value:
    for logger in debug.loggers:
        logger.log("Example:",  example_value)
```

<div dir="rtl">
با این حال، این موردی است که می‌توان `example_value` را حذف نمود چرا که `example_value` فقط یک نتیجه میانی را نگه می‌دارد و همان گونه که در قسمت حذف نتایج میانی دیدیم، متغیرهایی شبیه به این، می‌توانند توسط «یک وظیفه را در اسرع وقت کامل کنید» حذف شوند. البته در این مورد به این معنی است که به محض پیدا کردن `example_value` مقدار آن را ثبت[22] کنید. کد جدید شبیه عبارت زیر خواهد بود:
</div>

```
def LogExample(value):
    for logger in debug.loggers:
        logger.log("Example:",  value)

if request:
    for value in request.values:
        if value > 0:
            LogExample(value)  # deal with 'value' immediately
            break
```

<div dir="rtl">
زبان برنامه‌نویسی اصلی C الزام می‌کرد که تعریف همه متغیرها در بالای تابع یا بلوک کد باشند و این موضوع، تاسف بار بود، زیرا برای توابع طولانی با متغیرهای زیاد، خواننده را مجبور می‌کرد در یک لحظه درباره همه آن متغیرها فکر کند، حتی اگر تا مدت زمان زیادی مورد استفاده قرار نگرفته باشند(البته C99 و C++ این الزام را حذف کردند).

در مثال زیر تمام متغیرها در بالای تابع تعریف شده‌اند:
</div>

```
def ViewFilteredReplies(original_id):

    filtered_replies = []
    root_message = Messages.objects.get(original_id)
    all_replies = Messages.objects.select(root_id=original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    for reply in all_replies:
        if reply.spam_votes \<= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
```

<div dir="rtl">
این کد خواننده را مجبور می‌کند تا هم‌زمان به سه متغیر فکر نموده و عمل فکر کردن را بین آن‌ها جابجا کند.

از آنجا که نیازی به دانستن همه آن‌ها تا زمانی که در آینده مورد استفاده قرار می‌گیرند، وجود ندارد، به راحتی می‌توان تعریف هر کدام را فقط به جایی که اولین بار استفاده خواهد شد جابجا نمود:
</div>

```
def ViewFilteredReplies(original_id):

    root_message = Messages.objects.get(original_id)
    root_message.view_count += 1

    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    all_replies = Messages.objects.select(root_id=original_id)
    filtered_replies = \[\]

    for reply in all_replies:
        if reply.spam_votes \<= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
```

<div dir="rtl">
شاید شما نگران باشید که `all_replies` یک متغیر ضروری است یا با انجام این کار می‌تواند حذف شود؟
</div>

```
for reply in Messages.objects.select(root_id=original_id):

...
```

<div dir="rtl">
از آن جا در این مثال all_replies متغیر را به خوبی توضیح می‌دهد، بنابراین ما تصمیم گرفتیم که آن را نگه داریم.

## ترجیح دادن متغیرهای Write-Once [23]

<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/9-Variables-and-Readability/img-9-1.png"/>
</p>

تا اینجای این فصل، سخن درباره چگونگی سخت بودن درک برنامه‌هایی بود که تعداد زیادی متغیر دارند. بی شک فکر کردن در مورد متغیرهایی که دائما در حال تغییر هستند سخت‌تر بوده و پیگیری مقدار آن‌ها دشواری دیگری را اضافه می‌کند. برای مقابله با این مشکل، ما پیشنهادی داریم که ممکن است کمی عجیب به نظر آید: متغیرهایی را که به صورت `Write-Once` نوشته می‌شوند، ترجیح دهید چرا که راحت‌تر می‌توان در مورد اینگونه متغیرهای که یک چیز ثابت هستند فکر کرد. همچون ثابت‌ها:
</div>

```
static const int NUM_THREADS = 10; 
```

<div dir="rtl">
استفاده از `const` در C++ (و Java نهایی) بسیار توصیه شده است.

در بسیاری از زبان‌ها (از جمله Python و Java) برخی از نوع‌های داخلی[24] مانند `string` تغییر ناپذیر[25] هستند. همان گونه که James Gosling (خالق جاوا) گفته است: «متغیرهای تغییرناپذیر معمولا بدون دردسر هستند».

به یاد داشته باشید که اگر نمی‌توانید متغیر خود را به صورت Write-Once بنویسید، اگر کاری کنید که متغیر در مکان‌های کمتری تغییر کند، باز هم کمک کننده خواهد بود.

> **_کلید طلایی:_** هرچه مکان یک متغیر بیشتر دستکاری شود، استدلال در مورد مقدار فعلی آن سخت‌تر خواهد شد.

شما چگونه این کار را انجام می‌دهید؟ چطور می‌توانید یک متغیر را که به صورت Write-Once است تغییر دهید؟ در اکثر مواقع، این کار نیاز به کمی بازسازی[26] کد دارد که در مثال بعدی به آن خواهیم پرداخت.

## مثال پایانی

به عنوان مثال آخر در این فصل، ما می‌خواهیم مثالی از بیشتر اصولی که تا کنون در مورد آن‌ها بحث کرده‌ایم را نشان دهیم.

فرض کنید یک صفحه وب با تعدادی فیلد متنی input دارید که به شکل زیر تنظیم شده است:
</div>

```
<input type="text" id="input1" value="Dustin">
<input type="text" id="input2" value="Trevor">
<input type="text" id="input3" value="">
<input type="text" id="input4" value="Melissa">
...
```

<div dir="rtl">

همان گونه قابل مشاهده است، `id` ‌ها با `input1` شروع شده و حالت افزایشی دارد.

وظیفه شما نوشتن تابعی به نام
`setFirstEmptyInput()` است که یک رشته را گرفته و آن را در اولین `<input> ` خالی روی صفحه(که در این مثال `input3` می‌باشد) قرار دهد. این تابع یا باید المان DOM که به‌روزرسانی شده بود و یا مقدار null را اگر هیچ input  خالی وجود نداشته باشد برگرداند. در اینجا چند کد برای انجام این کار وجود دارد که اصول مطرح شده در این فصل را رعایت نمی‌کنند:

</div>

```
var setFirstEmptyInput = function (new_value) {

    var found = false; 

    var i = 1; 

    var elem = document.getElementById('input' + i); 

    while (elem !== null) {

        if (elem.value === '') {

            found = true; 

            break; 

        }

        i++; 

        elem = document.getElementById('input' + i); 

    }

    if (found) elem.value = new_value; 

    return elem; 

}; 
```

<div dir="rtl">

هر چند این کد کار خواسته شده را انجام می‌دهد، اما زیبا نیست. مشکل این کد چیست؟ و چگونه می‌توانیم آن را بهبود دهیم؟

راه‌های زیادی برای فکر کردن در مورد بهبود این کد وجود دارد، اما ما می‌خواهیم آن را از لحاظ متغیرهای مورد استفاده، در نظر بگیریم، یعنی:

* متغیر `var found`

* متغیر `var i`

* متغیر `var elem`

هر سه متغیر در کل تابع وجود داشته و چندین بار نوشته شده‌اند. بیایید سعی کنیم استفاده از هر کدام را بهبود دهیم. همانطور که در ابتدای فصل بحث کردیم، اغلب می‌توان متغیرهای واسطه‌ای[27]  مانند `found` را با برگرداندن[28] زودهنگام حذف نمود. نسخه بهبود یافته کد به این صورت است:

</div>

```
var setFirstEmptyInput = function (new_value) {

    var i = 1; 

    var elem = document.getElementById('input' + i); 

    while (elem !== null) {

        if (elem.value === '') {

            elem.value = new_value; 

            return elem; 

        }

        i++; 

        elem = document.getElementById('input' + i); 

    }

    return null; 

}; 
```

<div dir="rtl">

حال نگاهی به `elem` بیندازید. این متغیر چندین بار در طول کد به صورت تکراری استفاده شده است و به همین دلیل ردیابی مقدارش سخت شده است. به نظر می‌رسد که کد را از طریق مقدار `elem` تکرار می‌کنیم، در حالی که واقعا فقط از طریق `i` افزایش انجام می‌شود. بنابراین بیایید حلقه `while` را در یک حلقه `for` روی `i` بازنویسی کنیم:
</div>

```
var setFirstEmptyInput = function (new_value) {

    for (var i = 1;  true;  i++) {

        var elem = document.getElementById('input' + i); 

        if (elem === null)

            return null;   *// Search Failed. No empty input found.*

        if (elem.value === '') {

            elem.value = new_value; 

            return elem; 

        }

    }

}; 
```

<div dir="rtl">

به این مورد توجه کنید که `elem` چگونه به عنوان یک متغیر `write-once` که طول عمر آن، درون حلقه است، عمل می‌کند. استفاده از `true` به عنوان شرط حلقه `for` غیرمعمول است، اما در عوض، می‌توانیم تعریف متغیر i و تغییراتش را در یک خط ببینیم. همچنین استفاده از یک حلقه `while(true)` سنتی نیز منطقی به نظر می‌رسد.

## خلاصه فصل

این فصل درباره این موضوع بود که چگونه متغیرهای یک برنامه می‌توانند سریعا روی هم تلنبار شده(زیاد شوند) و پیگیری آن‌ها سخت شود. شما می‌توانید با داشتن متغیرهای کمتر و تبدیل آن‌ها به صورت سبک تا حد ممکن کد خود را برای خواندن ساده‌تر کنید. به طور مشخص:

* **از بین بردن متغیرهایی،** که فقط در مسیر هستند، همچون مدیریت مستقیم نتیجه[29]های واسط با از بین بردن متغیرهای واسط.

* **کاهش محدوده هر متغیر،** تا حد امکان با جابجا کردن هر متغیر به مکانی که بتوان در خطوط کمتری از کد، آن را مشاهده کرد. زیرا چیزی که خارج از دید باشد، خارج از ذهن نیز خواهد بود.

* ترجیح دادن متغیرهای `write-once`یعنی متغیرهایی که فقط برای یک مرتبه تنظیم می‌شوند(همچون `const`، `final` یا دیگر متغیرهای تغییرناپذیر) که سبب ساده‌تر شدن خواندن کد می‌شوند.
</div>

[1] sloppy

[2] Eliminating Variables

[3] explaining

[4] summary

[5] Temporary

[6] leftovers

[7] Intermediate

[8] structured programming

[9] Eric Brechner’s I. M. Wright’s “Hard Code” (Microsoft Press, 2007), 
p. 166.

[10] scope

[11] Shrink

[12] global

[13] polluting the namespace

[14] mini-global

[15] realm

[16] Static methods

[17] isolated

[18] data

[19] best practice

[20] block scope

[21] exception

[22] logging

[23] منظور متغیرهایی است که یک مرتبه تعریف شده و مقدار
آن در طول برنامه تغییر داده نمی‌شود.

[24] built-in

[25] immutable

[26] restructuring

[27] intermediate

[28] returning

[29] intermediate result
