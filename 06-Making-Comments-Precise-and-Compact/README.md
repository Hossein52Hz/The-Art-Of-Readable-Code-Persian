
<div dir='rtl'>

# فصل ششم ساختن کامنت‌ها به شکل دقیق و خلاصه

</div>
<p align="center">
    <img src="https://github.com/Hossein52Hz/The-Art-Of-Readable-Code-Persian/blob/main/06-Making-Comments-Precise-and-Compact/img-6-1.png" />
</p>

<div dir='rtl'>

موضوع فصل قبل این بود که بفهمیم «چه چیزی را باید کامنت گذاری کنیم»، این فصل در این مورد است که «چگونه کامنتی بنویسیم که دقیق و خلاصه باشد».

اگر می‌خواهید یک کامنت خوب بنویسید، باید دقیق، خاص و در حد امکان با جزئیات باشد. اما از آنجا که، کامنت‌ها فضای اضافی روی صفحه نمایش را اشغال کرده و زمان بیشتری را برای خواندن کد می‌گیرند باید مختصر(خلاصه و جمع و جور) باشند.

> **_کلید طلایی:_**  کامنت‌ها باید نسبت به فضایی که اشغال می‌کنند، نرخ بالایی از اطلاعات را شامل شوند.

در ادامه این فصل مثال‌هایی داریم که نشان می‌دهد چگونه این کار را انجام دهید.

## کامنت‌ها را خلاصه نگه دارید

در اینجا مثالی از یک کامنت برای تعریف یک DataType در C++ را ملاحضه می‌کنید:

</div>

```
// The int is the CategoryType.
// The first float in the inner pair is the 'score',
// the second is the 'weight'.
typedef hash_map<int, pair<float, float> > ScoreMap;
    
```
<div dir='rtl'>

اما چرا یک کامنت سه خطی برای توضیح آن استفاده شده است، وقتی که شما می‌توانید آن را فقط در یک خط نشان دهید؟

</div>

```
// CategoryType -> (score, weight)
typedef hash_map<int, pair<float, float> > ScoreMap;
  
```
<div dir='rtl'>

هرچند بعضی کامنت‌ها به سه خط از فضا نیاز دارند، اما بی شک این یکی از آن مدل‌‌ها نیست.

## از استفاده از ضمایر مبهم خودداری کنید

همان‌گونه که می‌دانید در تلفظ زبان انگلیسی ممکن است جمله Who’s on First معانی مختلفی داشته باشد و می‌تواند خواننده را دچار ابهام کند چرا که خواننده باید با انجام کار اضافی مشکل مرجع ضمیر این جمله را حل کند. در بعضی موارد، این که کلمات it یا this به چه چیزی اشاره می‌کنند، واضح نیست. به عنوان مثال:

</div>

```

// Insert the data into the cache, but check if it's too big first.
    
```
<div dir='rtl'>

در این کامنت، کلمه it ممکن است به داده یا حافظه موقت اشاره کند. هرچند شما با خواندن بقیه کد ممکن است بفهمید که دقیقا به چه چیزی اشاره می‌کند ولی اگر مجبور شوید که این کار را انجام دهید، پس چه مزیتی در استفاده از کامنت وجود دارد؟

در صورت وجود احتمال هرگونه ابهام یا سردرگمی، بهترین کار این است که به جای ضمیرهایی مانند it و this، کلمه اصلی جایگزین شود. فرض کنید در مثال قبلی منظور از it کلمه the data است:


</div>

```

// Insert the data into the cache, but check if the data is too big first.
    
```
<div dir='rtl'>

این ساده‌ترین تغییر برای درست کردن آن است. همچنین می‌توانید با بازنویسی جمله کلمه it را واضح‌تر کنید:

</div>

```

// If the data is small enough, insert it into the cache.
    
```
<div dir='rtl'>

## جملات درهم و برهم لهستانی1

در بسیاری از موارد دقیق‌تر کردن یک کامنت وابسته به خلاصه کردن آن است. در اینجا مثالی از یک خزنده وب2 داریم:


</div>

```

# Depending on whether we've already crawled this URL before, give it a different priority.
    
```
<div dir='rtl'>

شاید به نظر برسد که این عبارت جمله خوبی است، اما آن را با کامنت زیر مقایسه کنید:
</div>

```

# Give higher priority to URLs we've never crawled before.
    
```
<div dir='rtl'>

بی شک این یکی ساده‌تر، کوتاه‌تر و دقیق‌تر است. همچنین توضیح می‌دهد که اولویت بالاتر1 به URL‌های کشف نشده اختصاص داده شده است در حالی که کامنت قبلی حاوی این اطلاعات نبود.

## رفتار یک تابع را به صورت دقیق شرح دهید

تصور کنید شما فقط یک تابع نوشته‌اید که تعداد خطوط یک فایل را می‌شمارد:

</div>

```

// Return the number of lines in this file.
int CountLines(string filename) { ... }
    
```
<div dir='rtl'>

این کامنت خیلی دقیق نیست. روش‌های خیلی زیادی برای تعریف یک خط یا line وجود دارد. در اینجا چند مورد corner1 را برای فکر کردن به آن آورده‌ایم:

</div>

* "" (an empty file)—0 or 1 line?
* "hello"—0 or 1 line?
* "hello\n"—1 or 2 lines?
* "hello\n world"—1 or 2 lines?
* "hello\n\r cruel\n world\r"—2, 3, or 4 lines?

<div dir='rtl'>

ساده‌ترین پیاده سازی این است که کاراکترهای خط جدید(\n) را بشماریم.( این همان روشی است که سیستم عامل Unix در دستور wc با آن کار می‌کند). در ادامه کامنتی بهتر، منطبق با این پیاده سازی را مشاهده می‌کنید:

</div>

```

// Count how many newline bytes ('\n') are in the file.
int CountLines(string filename) { ... }
    
```
<div dir='rtl'>

با اینکه این کامنت خیلی طولانی‌تر از نسخه اول نیست، اما شامل اطلاعات بیشتری است. این کامنت به خواننده می‌گوید که، اگر هیچ خط جدیدی وجود نداشته باشد، تابع مقدار 0 را بر می‌گرداند1. همچنین می‌گوید که کاراکتر سرخط2(\r) نادیده گرفته شده است.

## از مثال‌های ورودی/خروجی3 که موردهای Corner را نشان می‌دهد استفاده کنید

وقتی صحبت از کامنت می‌شود، یک مثال ورودی/خروجی که با دقت انتخاب شده باشد، می‌تواند به اندازه هزاران کلمه ارزش داشته باشد.

به عنوان مثال در اینجا یک تابع معمولی داریم که بخشی از یک رشته را حذف می‌کند:

</div>

```

// Remove the suffix/prefix of 'chars' from the input 'src'.
String Strip(String src, String chars) { ... }
    
```
<div dir='rtl'>

این کامنت خیلی دقیق نیست زیرا نمی‌تواند به این سوالات پاسخ دهد:

* آیا chars یک زیر رشته است که باید حذف شود و یا فقط مجموعه‌ای از متن‌های نامرتب است؟
* اگر چندین chars در پایان src وجود داشته باشد چه می‌شود؟

به جای آن، یک مثال خوب که می‌تواند به این سوالات پاسخ دهد عبارت است از:

</div>

```

// ...
// Example: Strip("abba/a/ba", "ab") returns "/a/"
String Strip(String src, String chars) { ... }
    
```
<div dir='rtl'>
این مثال عملکرد Strip() را به شکل کامل نشان می‌دهد. توجه داشته باشید که یک مثال ساده‌تر، اگر به سوالات پاسخ ندهد، مفید نخواهد بود:

</div>

```

// Example: Strip("ab", "a") returns "b"

```
<div dir='rtl'>

در اینجا مثال دیگری از تابعی که می‌تواند به طور مشابه استفاده شود، داریم:

</div>

```

// Rearrange 'v' so that elements < pivot come before those >= pivot;
// Then return the largest 'i' for which v[i] < pivot (or -1 if none are < pivot)
int Partition(vector<int>* v, int pivot);
    
```
<div dir='rtl'>

هر چند این کامنت خیلی دقیق است، اما تصور آن کمی دشوار می‌باشد. در ادامه مثالی داریم که می‌توانید برای نشان دادن اطلاعات دقیق‌تر، موارد بیشتری را به کامنت اضافه کنید:

</div>

```

// ...
// Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1
int Partition(vector<int>* v, int pivot);
    
```
<div dir='rtl'>

نکاتی در مورد مثال‌های خاصی که برای ورودی/خروجی انتخاب کردیم وجود دارد که عبارتند از:

* مقدار pivot برابر است با المانی در وکتور برای نشان دادن مورد لبه‌ای1.
* ما کپی‌هایی را داخل vector(8) قرار دادیم برای اینکه نشان دهیم ورودی قابل قبول است.
* نتیجه vector مرتب شده نیست. در صورت مرتب شده بودن ممکن بود خواننده ایده اشتباهی از آن برداشت کند.
* از آنجا که مقدار برگشتی برابر ۱ بود، اطمینان حاصل کردیم که دیگر ۱ به عنوان یک مقدار داخل وکتور نباشد چرا که گیج کننده می‌شد.

## هدف کد خود را مشخص کنید

همانگونه که در فصل قبل اشاره کردیم، اغلب کامنت گذاری درباره این است که به خواننده بگویید شما هنگام نوشتن کد در حال فکر کردن به چه چیزی بوده‌اید. متاسفانه بسیاری از کامنت‌ها بدون اینکه اطلاعات جدیدی ارائه دهند، فقط توصیف می‌کنند که کد چه کاری انجام می‌دهد. در اینجا مثالی از این نوع کامنت داریم:

</div>

```

void DisplayProducts(list<Product> products) {
    products.sort(CompareProductByPrice);
    // Iterate through the list in reverse order
    for (list<Product>::reverse_iterator it = products.rbegin(); it != products.rend();
         ++it)
        DisplayPrice(it->price);
    ...
}
    
```
<div dir='rtl'>

تمام کاری که این کامنت انجام می‌دهد این است که فقط خط پایین خود را توصیف می‌کند. به جای آن این کامنت بهتر را در نظر بگیرید:

</div>

```

// Display each price, from highest to lowest
    for (list<Product>::reverse_iterator it = products.rbegin(); ... )

```

<div dir='rtl'>

این کامنت توضیح می‌دهد که برنامه در سطح بالا در حال انجام کار بوده و این با آنچه برنامه‌نویس هنگام نوشتن کد به آن فکر می‌کرد، خیلی بیشتر منطبق است.

خصوصا که در این برنامه یک اشکال1 وجود دارد! تابع CompareProductByPrice (نمایش داده نشده) ابتدا آیتم‌های با قیمت بالاتر را مرتب می‌کند و این برعکس آن چیزی است که نویسنده قصد انجامش را داشته است.

این دلیل خوبی برای بهتر بودن کامنت دوم است. با وجود این اشکال، کامنت اول از نظر فنی درست است(حلقه به ترتیب معکوس تکرار می‌شود). اما با کامنت دوم، احتمالا خواننده بهتر متوجه می‌شود که هدف نویسنده ابتدا نشان دادن آیتم‌ها با قیمت بالاتر بوده، که این دقیقا کاری که واقعا کد انجام می‌دهد را در کامنت تکرار نکرده است.

در واقع این کامنت به عنوان یک بررسی افزونگی2 عمل می‌کند.

هر چند در نهایت بهترین روش بررسیِ افزونگی استفاده از تست واحد است(در فصل ۱۴ به آن پرداخته شده است). اما هنوز هم کامنت‌هایی مانند این، که در مورد هدف برنامه شما توضیح می‌دهند، ارزشمند هستند.

## کامنت گذاری نام پارامترهای تابع

فرض کنید یک فراخوانی تابع شبیه کد زیر را مشاهده می‌کنید:
</div>

```

Connect(10, false);
    
```

<div dir='rtl'>

این فراخوانی تابع به دلیل اینکه integer و Boolean به آن پاس می‌شود، کمی مبهم است.

در زبان‌هایی شبیه پایتون، شما می‌توانید نامی را به آرگومان‌ها اختصاص دهید:

</div>

```

def Connect(timeout, use_encryption):  ...
# Call the function using named parameters
Connect(timeout = 10, use_encryption = False)

```

<div dir='rtl'>

اما در زبان‌هایی شبیه C++ و Java که امکان چنین کاری نیست، می‌توانید از کامنت inline به همین منظور استفاده نمایید:

</div>

```

void Connect(int timeout, bool use_encryption) { ... }
// Call the function with commented parameters
Connect(/* timeout_ms = */ 10, /* use_encryption = */ false);

```
<div dir='rtl'>

توجه داشته باشید که پارامتر اول را به جای timeout با عبارت timeout_ms نام‌گذاری کردیم. در حالت ایده‌آل، آرگومان واقعی تابع timeout_ms خواهد بود، اما اگر به دلایلی نتوانیم این تغییر(یعنی اضافه کردن _ms به انتهای نام در کامنت) را انجام دهیم، این یک روش دستی برای بهبود نام خواهد بود.

وقتی آرگومان‌های Boolean استفاده می‌شوند، این خیلی مهم است که در جلوی مقدار1، کامنتِ /* name = */ را قرار دهید. قرار دادن کامنت بعد از مقدار خیلی گیج کننده است:

</div>

```

// Don't do this!
Connect( ... , false /* use_encryption */);
// Don't do this either!
Connect( ... , false /* = use_encryption */);

```

<div dir='rtl'>

در این مثال‌ها، اینکه معنی کلمه false جمله use encription‌ است یا don’t use encryption واضح نیست.

هر چند اکثر فراخوانی توابع، نیازی به کامنت‌هایی شبیه این ندارند، اما این روش دستی(و جمع و جور) برای توضیح آرگومان‌هایی که مبهم به نظر می‌رسند، بسیار مفید است.

## از کلمات Information-Dense استفاده کنید

بعد از چندین سال برنامه‌نویسی، متوجه می‌شوید که مشکلات و راه حل‌های مشابه به صورت مرتب پیش می‌آید. اغلب، کلمات یا اصطلاحات خاصی که برای توصیف این الگوها یا اصطلاحات ایجاد شده‌اند، وجود دارد. استفاده از این کلمات می‌تواند کامنت‌های شما را بسیار جمع و جور‌تر کند.

به عنوان مثال، فرض کنید شما چنین کامنتی داشتید:

</div>

```

// This class contains a number of members that store the same information as in the
// database, but are stored here for speed. When this class is read from later, those
// members are checked first to see if they exist, and if so are returned; otherwise the
// database is read from and that data stored in those fields for next time.

```

<div dir='rtl'>

به جای آن شما می‌توانستید فقط بگویید:

</div>

```

// This class acts as a caching layer to the database.

```

<div dir='rtl'>

همچنین به عنوان مثالی دیگر کامنتی شبیه این را در نظر بگیرید:

</div>

```

// Remove excess whitespace from the street address, and do lots of other cleanup
// like turn "Avenue" into "Ave." This way, if there are two different street addresses
// that are typed in slightly differently, they will have the same cleaned-up version and
// we can detect that these are equal.

```

<div dir='rtl'>

به جای آن می‌توانستید بگویید:

</div>

```

// Canonicalize the street address (remove extra spaces, "Avenue" -> "Ave.", etc.)

```

<div dir='rtl'>

کلمات و اصطلاحات زیادی وجود دارد که معانی خیلی زیادی را در خود دارند، مانند کلمه heuristic، brute force، naive solution و کلمات مشابه دیگر. اگر کامنتی دارید که احساس می‌کنید کمی طولانی است، بررسی کنید که آیا می‌توان آن را به عنوان یک وضعیت برنامه‌نویسی معمولی توصیف کرد یا خیر؟

## خلاصه فصل

این فصل درباره نوشتن کامنت‌هایی است که اطلاعات زیادی را در یک فضای کوچک و در کمترین زمان ممکن در اختیار شما قرار می‌دهد. نکات خاص این فصل عباتند از:

* از ضمیرهایی مانند it و this (هنگامی که به چندین چیز اشاره می‌کنند) خودداری کنید.
* رفتار یک تابع را با همان دقت عملی توصیف کنید.
* کامنت‌های خود را با مثال‌های ورودی/خروجی که با دقت انتخاب شده‌اند، نشان دهید.
* به جای جزئیات، هدف سطح بالای کد خود را واضح بیان کنید.
* از کامنت‌های درون خطی یا inline (مثلا Function(/* arg = */ ... )) برای توضیحِ ابهامِ آرگومان‌های تابع استفاده کنید.
* کامنت‌های خود را با استفاده از کلماتی که معنای زیادی را در خود دارند کوتاه نگه دارید.

<div>
[1]: 
<br>
[2]: 
<br>
[3]: 
<br>
[4]: 
<br>
[5]: 
<br>
[6]: 
<br>
[7]: 
<br>
[8]: 
<br>
[9]: 
<br>
[10]: 
<br>
[11]: 
<br>
[12]: 
<br>
[13]: 
<br>
[14]: 
<br>
[15]: 
<br>
[16]: 
<br>
[17]: 
<br>
[18]: 
<br>
[19]: 
<br>
[20]: 
<br>
[21]: 
<br>
[22]: 
<br>
[23]: 
<br>
[24]: 
<br>
[25]: 
<br>
[26]: 
<br>
[27]: 
<br>
[28]: 
</div>

